# Паттерн «Цепочка обязанностей» (Chain of Responsibility)

## Краткое тезисное определение

Порождающе-поведенческий паттерн (в GoF — поведенческий), позволяющий передавать запрос по последовательности (цепочке) обработчиков до тех пор, пока один из них не обработает его (или пока не закончатся обработчики).

> Ключевая идея — отправитель запроса не знает, **кто именно** его обработает.

> Это снижает связанность, повышает расширяемость и позволяет динамически конфигурировать цепочку.

---

## Что конкретно делает паттерн (о связях и удобстве)

- **Развязывает отправителя и получателя**: код, формирующий запрос, не завязан на конкретный обработчик.
- **Инкапсулирует условную логику выбора обработчика**: вместо набора `if/else` или `switch`— цепочка объектов.
- **Позволяет менять порядок и состав обработчиков во время исполнения** (динамическая конфигурация, DI, плагины).
- **Поддерживает расширение без модификации** существующего кода — добавляем новый обработчик, включаем в цепочку.
- **Упрощает тестирование** отдельных звеньев (обработчиков) изолированно.
- **Распределяет ответственность**: каждый обработчик концентрируется на одной задаче / критерии.

Тип связей:

- Обычно **ассоциация** или **агрегация** между обработчиками (звено хранит ссылку на следующее).
- Может применяться **композиция** (жесткая связь — сборка цепи внутри одного агрегирующего объекта).
- Реже — наследование для специализации базового обработчика.

---

## Ограничения и когда не подходит

| Ограничение / Риск                    | Пояснение                                   | Что делать                                                               |
| ------------------------------------- | ------------------------------------------- | ------------------------------------------------------------------------ |
| Неочевидный путь обработки            | Трудно отследить, кто обработал             | Логирование, трассировка (correlation id)                                |
| Возможны «пустые прогоны»             | Если много обработчиков «пропускают» запрос | Сегментация цепи, фильтрация по метаданным                               |
| Сложность при изменении контракта     | Если формат запроса меняется по пути        | Иммутабельный контекст с накоплением, версия объекта, pattern «Pipeline» |
| Трудно дебажить при динамичной сборке | Конфиг цепи может быть внешним              | Генерация «карты цепи» для диагностики                                   |
| Нельзя гарантировать обработку        | Никто не обязан обработать                  | Добавить «последний” fallback-обработчик                                 |
| Перекрытие ответственности            | Обработчики начинают знать друг о друге     | Ввести строгие зоны ответственности                                      |
| Производительность                    | Глубокая цепочка + синхронная обработка     | Батчинг, укрупнение, короткие пути                                       |
| Побочные эффекты                      | Мутация запроса ломает другие звенья        | Иммутабельный паттерн или snapshotting                                   |
| Ошибки и отмена                       | Ошибка «глубоко» — кто откатывает?          | Протокол отмены (compensation) или saga-like подход                      |

### Если «контракт может изменяться» (запрос трансформируется по пути)

Подходы:

1. **Иммутабельный контекст + новые версии**: каждый обработчик возвращает новый объект (structural sharing).
2. **Context bag (словарь / Map)**: добавляем/читаем ключи. Минус — расползание неявных зависимостей.
3. **Типобезопасный контекст** через Discriminated Union / Result типы.
4. **Пайплайн с стадиями**: каждый шаг моделируется как трансформация `StageIn -> StageOut`.
5. **Wrapper-модель**: «обогащение» через декоратор (но тогда мы уже частично смешиваем паттерны).
6. **Слой валидации контракта** перед передачей дальше (fail-fast).

---

## Когда полезно (признаки применимости)

Используйте, если:

- Много потенциальных обработчиков, но заранее неизвестно кто сработает.
- Логика выбора обработчика часто меняется.
- Нужно упростить ветвящуюся условную логику (`if/else if/...`).
- Требуется легко добавлять/удалять/переупорядочивать этапы.
- Возможна интеграция плагинов (внешних модулей).
- Нужно делегировать обработку «до первого успеха» или «до исчерпания».
- Есть паттерн «middleware» (HTTP, RPC, события, UI-пайплайны).
- Нужно внедрить кросс-сечения (логирование, метрики, security) без загрязнения логики.

---

## Варианты реализации

### 1. Классическая цепочка (передает дальше всегда)

```ts
interface Handler {
  setNext(h: Handler): Handler;
  handle(req: Request): void;
}

abstract class BaseHandler implements Handler {
  private next?: Handler;
  setNext(h: Handler): Handler {
    this.next = h;
    return h;
  }
  protected nextHandle(req: Request) {
    this.next?.handle(req);
  }
}

class A extends BaseHandler {
  handle(req: Request) {
    // делаем что-то (всегда)
    this.nextHandle(req);
  }
}
```

### 2. Цепочка с прерыванием (останавливается при обработке)

```ts
interface Handler {
  setNext(h: Handler): Handler;
  handle(req: Request): boolean; // true = обработал / стоп
}

abstract class Stoppable implements Handler {
  private next?: Handler;
  setNext(h: Handler): Handler {
    this.next = h;
    return h;
  }
  protected pass(req: Request): boolean {
    return this.next ? this.next.handle(req) : false;
  }
}

class AuthHandler extends Stoppable {
  handle(req: Request): boolean {
    if (!req.auth) return true; // останов — не прошёл
    return this.pass(req);
  }
}
```

### 3. Гибкая цепочка (каждый решает — продолжать или нет)

Возвращаем enum / Result:

```ts
enum Flow {
  Continue,
  Stop,
}
interface Handler {
  handle(ctx: Ctx): Flow;
}
```

### 4. Наследование

Базовый абстрактный класс дает каркас. Минус — может вести к жесткой иерархии, хуже композиции.

### 5. Агрегация (ссылка передается в конструктор)

```ts
class HandlerA {
  constructor(private next?: HandlerA) {}
  handle(req: Req) {
    // ...
    this.next?.handle(req);
  }
}
```

### 6. Композиция (цепь строится централизованно)

```ts
class Chain {
  constructor(private handlers: Handler[]) {}
  run(req: Req) {
    for (const h of this.handlers) h.handle(req);
  }
}
```

(Это ближе к «пайплайну» — все выполняются.)

### 7. Ассоциация через setter (динамическая сборка)

```ts
h1.setChainSuccessor(h2);
h2.setChainSuccessor(h3);
```

Позволяет менять на лету.

### 8. Функциональный вариант (pipeline / reduce)

```ts
type Handler = (req: Req) => Req;
const pipeline =
  (...hs: Handler[]) =>
  (initial: Req) =>
    hs.reduce((acc, h) => h(acc), initial);
```

### 9. Middleware-стиль (async + next)

(Похоже на Express / Koa)

```ts
type Middleware = (ctx: Ctx, next: () => Promise<void>) => Promise<void>;

function compose(middlewares: Middleware[]) {
  return (ctx: Ctx) => {
    let index = -1;
    const dispatch = (i: number): Promise<void> => {
      if (i <= index) return Promise.reject(new Error("next() called twice"));
      index = i;
      const fn = middlewares[i];
      if (!fn) return Promise.resolve();
      return fn(ctx, () => dispatch(i + 1));
    };
    return dispatch(0);
  };
}
```

### 10. Реализация через цепочку Observables, генераторов и т.п.

RxJS: поток превращается в последовательность операторов (mapping chain) — функционально близко, но семантика реактивна.

---

## OOP vs Функциональный стиль

| Критерий      | OOP                       | FP                             |
| ------------- | ------------------------- | ------------------------------ |
| Расширяемость | Добавляем класс           | Добавляем функцию              |
| Состояние     | Может быть внутреннее     | Чаще без состояния (чистые)    |
| Тестирование  | Мокаем классы             | Тестируем чистые функции       |
| Динамика      | Пересборка объектов       | Перестановка функций в массиве |
| Полиморфизм   | Наследование / интерфейсы | Высшего порядка функции        |
| Ошибки        | Исключения                | Типы `Either/Result`           |
| Асинхронность | Методы `async handle`     | Композиция промисов / монады   |

Ограничения FP варианта:

- Сложнее имплементировать «короткое замыкание» без явных `return`/`break`.
- Иногда сложнее внедрять побочные эффекты прозрачно.

Ограничения OOP:

- Многословность, бойлерплейт.
- Риск разрастания иерархии.

---

## Является ли набор последовательных if реализацией Chain of Responsibility?

### Пример:

```ts
if (cond1) return handler1(req);
if (cond2) return handler2(req);
if (cond3) return handler3(req);
```

Или:

```ts
handler1(req) || handler2(req) || handler3(req);
```

Это **не полноценный** паттерн «Цепочка обязанностей», а **структурно эквивалентная плоская форма** его логики:

- Похожие семантика (первый сработавший — победил).
- Нет инкапсуляции обработчиков как независимых объектов.
- Нет гибкой динамической конфигурации (нужно переписывать код).
- Отправитель «знает» порядок и сами обработчики (сильная связанность).
- Сложнее переиспользовать части вне общей функции.

Можно сказать: это **упрощенное, неинкапсулированное** выражение той же идеи. Формально — **не паттерн**, а «конкретный императивный код».
Если вынести каждую проверку в отдельный объект и собрать в цепь — станет паттерном.

---

## Подводные камни при мутации запроса

Риски:

- Порядкозависимость (медленно выявляемые баги).
- Непредсказуемость (обработчики начинают полагаться на побочные эффекты предыдущих).
- Трудно тестировать отдельно (нужен «правильный» предварительный state).
- Race conditions (в асинхронной цепи).
- Кэширование / оптимизации рушатся.

Лучшие практики:

1. Использовать иммутабельные структуры (`{ ...req, newField }`).
2. Паттерн «Context + Events»: обработчик добавляет событие или артефакт, не переписывая всё.
3. Чётко документировать контракт на вход/выход (`interface StageOut extends StageIn { added: X }`).
4. Ввести схемы (Zod / io-ts) для валидации после шагов.
5. Логировать изменения (diff).
6. Применять copy-on-write (только если есть изменения).
7. Если нужно «накопить» — использовать `accumulator`.

---

## Как передавать результат дальше

Варианты:

- Возвращать модифицированный контекст.
- Возвращать `Either<Error, Context>` (fail-fast).
- Возвращать `Promise<Context>` для асинхронной цепи.
- Протокол `handle(ctx, next)` (middleware).
- Возвращать `{ ctx, decision: Flow }` для ветвления.
- Использовать «Result pipeline» (Railway Oriented Programming).

---

## Асинхронная цепочка

Простой пример:

```ts
interface AsyncHandler {
  setNext(h: AsyncHandler): AsyncHandler;
  handle(req: Req): Promise<Req>;
}

class Base implements AsyncHandler {
  private next?: AsyncHandler;
  setNext(h: AsyncHandler) {
    this.next = h;
    return h;
  }
  protected async nextHandle(req: Req) {
    return this.next ? this.next.handle(req) : req;
  }
}
```

Middleware-подход (как в Koa):

- Каждый обработчик вызывает `await next()`.
- Можно вставлять кросс-секционные задачи (логирование, таймеры).
- Можно реализовать отмену (не вызывая `next` или бросив ошибку).

Особенности:

- Ошибки — через `try/catch`.
- Параллельная работа: иногда полезно запускать «ветвления», но это уже не чистая линейная цепь.
- Можно внедрить токен отмены (`AbortSignal`).

---

## Примеры применения во фронтенде

### 1. Валидация формы (цепочка правил)

```ts
type Validator = (data: Form) => string | null;

const required: Validator = (d) => (d.name ? null : "Name required");
const email: Validator = (d) => (/@/.test(d.email) ? null : "Bad email");

function runValidators(vs: Validator[], data: Form): string[] {
  return vs.map((v) => v(data)).filter(Boolean) as string[];
}
```

(Это скорее pipeline; если останавливаемся на первой ошибке — ближе к Chain of Responsibility.)

### 2. HTTP запросы — перехватчики (fetch middleware)

- Добавление заголовков (Auth)
- Кеширование
- Ретрай
- Логирование

### 3. React: рендер-пайплайн для преобразования пропсов

```ts
type PropsHandler = (p: Props) => Props;
const enhance =
  (...hs: PropsHandler[]) =>
  (p: Props) =>
    hs.reduce((acc, h) => h(acc), p);
```

### 4. React Error / Suspense Boundaries — каскадная передача «ответственности» вверх — концептуально похоже.

### 5. MobX: цепочка трансформаций / подготовка snapshot перед сохранением.

### 6. Роутинг / Guards

- Guard1 (auth?)
- Guard2 (role?)
- Guard3 (featureFlag?)

### 7. Обработка событий (например, keydown)

- Первый обработчик: хоткей
- Второй: навигация
- Третий: fallback (preventDefault)

### 8. Нормализация пользовательского ввода (маски, trim, canonicalization)

### 9. Client-side pipeline для подготовки данных к аналитике (PII stripping → enrichment → batching).

---

## Сравнение с похожими паттернами

| Паттерн    | Отличие                                                                                                   |
| ---------- | --------------------------------------------------------------------------------------------------------- |
| Decorator  | Оборачивает объект, расширяя интерфейс; цепочка — про выбор обработчика                                   |
| Pipeline   | Все стадии выполняются последовательно (нет «кто-то один»). Однако реализация может совпадать по механике |
| Strategy   | Выбирается один алгоритм заранее, а не определяется динамически в ходе прохождения                        |
| Middleware | Практический шаблон, частный случай цепочки для запроса/ответа                                            |
| Observer   | Множество подписчиков — все уведомлены; цепочка — обычно линейная последовательность «до обработки»       |

---

## Расширенные подходы

### Паттерн с «маршрутизатором»

Вместо линейного successor — таблица маршрутизации (graph chain). Это уже ближе к **Chain + Mediator**.

### Аналитика и метрики

Автоматическое измерение времени каждого звена — вставка профилирующего обработчика.

### Контекст с «слоями»

Stack-like context (push/pop) позволяет «логически» сегментировать изменения.

---

## Пример комплексной реализации (TypeScript)

```ts
interface Context {
  raw: string;
  parsed?: any;
  user?: { id: string };
  errors: string[];
}

enum Flow {
  Continue,
  Stop,
}

interface Handler {
  handle(ctx: Context): Promise<{ ctx: Context; flow: Flow }>;
  setNext(h: Handler): Handler;
}

abstract class AbstractHandler implements Handler {
  private next?: Handler;
  setNext(h: Handler): Handler {
    this.next = h;
    return h;
  }

  protected async nextHandle(
    ctx: Context
  ): Promise<{ ctx: Context; flow: Flow }> {
    if (!this.next) return { ctx, flow: Flow.Stop };
    return this.next.handle(ctx);
  }

  abstract handle(ctx: Context): Promise<{ ctx: Context; flow: Flow }>;
}

class ParseJson extends AbstractHandler {
  async handle(ctx: Context) {
    try {
      return await this.nextHandle({ ...ctx, parsed: JSON.parse(ctx.raw) });
    } catch {
      return {
        ctx: { ...ctx, errors: [...ctx.errors, "Invalid JSON"] },
        flow: Flow.Stop,
      };
    }
  }
}

class RequireUser extends AbstractHandler {
  async handle(ctx: Context) {
    if (!ctx.parsed?.userId) {
      return {
        ctx: { ...ctx, errors: [...ctx.errors, "No userId"] },
        flow: Flow.Stop,
      };
    }
    return this.nextHandle({ ...ctx, user: { id: ctx.parsed.userId } });
  }
}

class FinalSink extends AbstractHandler {
  async handle(ctx: Context) {
    // финальная обработка
    return { ctx, flow: Flow.Stop };
  }
}

// Сборка
const chain = new ParseJson();
chain.setNext(new RequireUser()).setNext(new FinalSink());

(async () => {
  const result = await chain.handle({ raw: '{"userId":"42"}', errors: [] });
  console.log(result);
})();
```

---

## Диагностика и наблюдаемость

Рекомендуется:

- Ввести traceId в контексте.
- Логировать вход/выход каждого обработчика.
- Собирать метрики времени.
- В тестах — снабжать mock-обработчики счётчиками вызовов.

---

## Итоговые рекомендации

1. Начните с простого (функциональный pipeline). Если нужен «первый, кто обработает» — переходите к цепочке с прерыванием.
2. Не переусложняйте: если 2–3 условия — обычные `if` приемлемы.
3. Применяйте цепочку, когда важна:
   - динамическая конфигурация,
   - расширяемость,
   - низкая связанность.
4. Избегайте неявной мутации контекста — предпочитайте иммутабельные возвращаемые значения.
5. Для асинхронной логики — middleware-композиция (Koa-подход).
6. Документируйте контракт между обработчиками (особенно если трансформируется).
7. Добавляйте fallback-обработчик.
8. Используйте типы `Result / Either` для ошибок вместо бросков (упрощает контроль потока).

---

## Краткий чеклист «нужна ли цепочка?»

- Много потенциальных обработчиков? Да → кандидат.
- Логика выбора часто меняется? Да → кандидат.
- Хочу добавлять обработчики без правки клиента? Да → кандидат.
- Нужна остановка при первом успехе или отказе? Да → кандидат.
- Нужна трассировка? Подумайте о встроенном логировании.
- Требуются побочные эффекты? Контролируйте их и документируйте.

---

## TL;DR

Цепочка обязанностей — способ делегировать решение «кто обработает запрос» группой обработчиков, последовательно пытающихся (или модифицирующих) контекст. Отличается от просто `if/else` тем, что создаёт **модульную, расширяемую структуру**. Правильная реализация снижает связанность и упрощает эволюцию системы, но требует строгой дисциплины в управлении контекстом, трассировкой и ошибками.
