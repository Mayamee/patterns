# Буферные объекты в WebGL — подробное практическое объяснение

## TL;DR (сверхкратко)

- **`createBuffer`** — создаёт _дескриптор_ ресурса (пустая "коробка" на стороне GPU/драйвера).
- **`bindBuffer(target, buf)`** — делает буфер **текущим** в слоте `target` (внутренний «активный» указатель).
- **`bufferData(target, data|size, usage)`** — **заливает байты** в текущий буфер (или выделяет память без данных).
- **`vertexAttribPointer(loc, size, type, normalized, stride, offset)`** — **связывает атрибут** с _АКТУАЛЬНО_ привязанным к `ARRAY_BUFFER` буфером + задаёт формат чтения.
- **`enableVertexAttribArray(loc)`** — включает поток данных из буфера в атрибут (иначе атрибут константный).
- **`drawArrays/Elements`** — запускает конвейер: GPU читает из буфера по правилам `vertexAttribPointer` и кормит вершинный шейдер.

---

## Большая картина: пайплайн данных

```text
[CPU / JS]                    [Driver/GPU Memory]                         [Vertex Shader]
Float32Array --> bufferData -->  VBO (ARRAY_BUFFER)  --vertexAttribPointer--> in vec2 a_Position
                                     ^   ^
                                     |   └ enableVertexAttribArray
                                     └ bindBuffer(ARRAY_BUFFER, ...)

draw* ---> GPU итерации по вершинам ---> читает атрибуты ----> исполняет вершинный шейдер
               |--> растеризация --> фрагментный шейдер --> framebuffer
```

Ключевая мысль: **шейдер никогда не читает ваш JS-массив напрямую**. Он читает **память GPU**, куда вы заранее скопировали байты.

---

## Почему `bindBuffer` не «типизирует», а что делает на самом деле

WebGL — это **машина состояний**. Внутри контекста есть _привязочные точки_ (binding points), например:

- `ARRAY_BUFFER` — «активный буфер верш. атрибутов»
- `ELEMENT_ARRAY_BUFFER` — «активный индексный буфер» (для `drawElements`)

Вызов:

```js
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
```

просто говорит: «Начиная с этого момента, **все функции, которые работают с `ARRAY_BUFFER`, будут применять изменения к `vertexBuffer`**».
Он _ничего не «типизирует»_ — он **переключает** «current buffer» для данного назначения (`target`).

---

## Что конкретно делает `bufferData`

Варианты использования:

1. `gl.bufferData(target, typedArray, usage)` — **копирует данные** из JS-памяти в GPU-память.
2. `gl.bufferData(target, sizeInBytes, usage)` — **выделяет память** под будущие данные (без копирования). Полезно для «orphaning» и стриминга.

Аргумент `usage` (`STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`) — **подсказка** драйверу о характере обновлений (не гарантия).

- `STATIC_DRAW`: один раз загрузили — много раз рисуем.
- `DYNAMIC_DRAW`: часто обновляем — много рисуем.
- `STREAM_DRAW`: один раз загрузили — мало раз рисуем.

**Важно:** после `bufferData` у GPU своя копия байтов. Изменение исходного `Float32Array` в JS **не** меняет содержимое буфера.

---

## Самое недооценённое место: семантика `vertexAttribPointer`

```js
gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
```

Это **не копирование** и не «привязка шейдера к массиву». Это **регистрация формата чтения** для атрибута _и фиксация ссылки на буфер, который БЫЛ привязан к `ARRAY_BUFFER` во время вызова_.

То есть:

1. У вас привязан некий буфер к `ARRAY_BUFFER`.
2. Вы вызываете `vertexAttribPointer(...)` — в этот момент в состояние атрибута записывается:

   - _какой буфер_ (тот, что **сейчас** в `ARRAY_BUFFER`),
   - _как читать_: `size` (1..4 компоненты), `type` (например, `FLOAT`), `normalized` (нормировать ли целые в [0,1] или [-1,1]),
   - _где в буфере лежат данные_: `stride` (байтов между вершинами) и `offset` (байтов от начала).

3. После этого вы можете **свободно менять `ARRAY_BUFFER`** — **атрибут уже «запомнил»** тот буфер, который был привязан в момент вызова.

**Частая ошибка:** думать, что `vertexAttribPointer` читает «из текущего `ARRAY_BUFFER` каждый раз заново». Нет, **он запоминает привязанный буфер на момент вызова**.

---

## Итог

- **Буфер** — это «коробка» в памяти GPU, в которую вы кладёте байты через `bufferData`.
- **Атрибут** — это правило «как читать» и «из какой коробки»; оно фиксируется `vertexAttribPointer` **в момент вызова**.
- **Отрисовка** — это просто запуск чтения по этим правилам для N вершин/инстансов.
